
var webpack = require("webpack");
var webpackConfig = require("./webpack2.config");
const {argv} = require('yargs');
if (argv.prod) {
    process.env.NODE_ENV = 'production';
}
let PROD = process.env.NODE_ENV === 'production';

var webpackOptionsMerged = {...webpackConfig,
    mode: PROD? "production" : "development",
    optimization : {
        usedExports: true
    },
    stats: { ...webpackConfig.stats ,
        usedExports: true,
        reasons: true,
        logging : "verbose" ,
        providedExports: true,
        env: true
    } ,
}
log.info("webpackOptionsMerged = ",webpackOptionsMerged)

const CONF_PATHS = {
    dist : "./dist",
    distTrackers : "./dist/trackers", // webpack built trackers ( bundled and compiled )
    tmp : "./tmp",
    SRC : "./src"
}
var dist = './dist'; // 出力先




let _webpack = (config, callback) => {
    return webpack(config, (err, stats) => {
            if(err)
                throw new PluginError("webpack:build", err);
            log("[webpack:build]", stats.toString({
                colors: true,
                usedExports: true, /// this correctly show webpack used exports
            }));
            return callback();
        }
    )
};

gulp.task('webpack2', (callback) => {
    //let myConfig = Object.create(webpackConfig);
    //let myConfig = Object.create(webpackOptionsMerged);
    return _webpack(webpackOptionsMerged, callback);
});

// 开始任务
gulp.task('start',shell.task([
    'gulp webpack-w'
]))


gulp.task('clean:mobile', () => {
    return del([
        'dist/report.csv',
        // here we use a globbing pattern to match everything inside the `mobile` folder
        'dist/mobile/**/*',
        // we don't want to clean this file though so we negate the pattern
        '!dist/mobile/deploy.json'
    ]);
});

gulp.task('clean:tmp', function () {
    return gulp.src('tmp/*')
        .pipe(vinylPaths(del))
        .pipe(stripDebug())
        .pipe(gulp.dest('dist'));
});
gulp.task('default', gulp.series('clean:mobile'));

gulp.task("clean:dist", function(done){
    return del([
        CONF_PATHS.dist,
        // here we use a globbing pattern to match everything inside the `mobile` folder
        //'dist/mobile/**/*',
        // we don't want to clean this file though so we negate the pattern
        //'!dist/mobile/deploy.json'
    ]);
    //done();
});

gulp.task("webpack", function(done){
    //webpackStream({...webpackConfig,mode: "production"}, webpack)

    webpackStream(webpackOptionsMerged, webpack)
        //.pipe(gulp.dest(CONF_PATHS.distTrackers));
    done();
});
function watch (cb) {
    return gulp.watch(
        './src/**/*', // watch everything...
        {
            ignored: [
                // ...except for things generated by the build process.
                'public/**/*',
                'static/assets/**/*'
            ]
        },
        // when something changes, rebuild + reload
        gulp.series("webpack")//, ssg('development'), reload)
    )
}


gulp.task("tslint", () =>
    gulp.src("./src/**/*.ts")
        .pipe(tslint({
            formatter: "verbose",
            configuration: "tslint.json"
        }))
        .on('error', printError)
        .pipe(tslint.report())
);

// print the error out
var printError = function(error) {
    console.log(error.toString());
}
// sourcemap only if not prod
//.pipe(cond(!PROD, sourcemaps.init()))


// // Per default, start scripts and styles
// gulp.task('default',
//     gulp.series('clean', gulp.parallel('scripts', 'styles'),
//         function() {...}));
// webpack追加
//gulp.task('default', gulp.series('sass', 'imagemin', 'webpack'), function(done) {
gulp.task('watch', gulp.series( 'clean:dist', 'webpack',watch))

gulp.task('default', gulp.series( 'clean:dist', 'webpack'), function(done) {
    done();
});

// doesn't work
// gulp.task('webpack-w',function(){
//     gulp.watch(CONF_PATHS.SRC+"/**/*",['webpack']);
// });
